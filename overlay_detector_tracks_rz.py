#!/usr/bin/env python3

import re
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from matplotlib.lines import Line2D
from matplotlib.backends.backend_pdf import PdfPages


# -----------------------------
# ROOT macro parser & renderer
# -----------------------------
def _get_color_hex(block):
    m = re.search(r'GetColor\("([^"]+)"\)', block)
    if m:
        return m.group(1)
    # fallbacks: SetTextColor( # ) or SetLineColor( # )
    m2 = re.search(r"Set(Text|Line)Color\((\d+)\)", block)
    if m2:
        # Map a few common ROOT color indexes (very rough)
        idx = int(m2.group(2))
        color_map = {
            1: "#000000",
            2: "#ff0000",
            4: "#0000ff",
            3: "#00ff00",
            6: "#ff00ff",
            5: "#00ffff",
            7: "#aaaaaa",
        }
        return color_map.get(idx, None)
    return None


def parse_root_macro(macro_path, units=1.0, z_shift=0.0, R_shift=0.0):
    """
    Parse a ROOT macro generated by TCanvas->SaveAs(".C").
    Apply optional unit scaling (units [cm/macro_unit]) and shifts (cm).
    Return: dict with keys 'range', 'polylines', 'lines', 'texts'.
    Coordinates are converted to cm and shifted.
    """
    src = open(macro_path, "r", encoding="utf-8", errors="ignore").read()
    # Canvas range
    m = re.search(
        r"\bRange\(\s*([-\d\.Ee+]+)\s*,\s*([-\d\.Ee+]+)\s*,\s*([-\d\.Ee+]+)\s*,\s*([-\d\.Ee+]+)\s*\)\s*;",
        src,
    )
    if m:
        xmin, ymin, xmax, ymax = [float(g) * units for g in m.groups()]
        xmin += z_shift
        xmax += z_shift
        ymin += R_shift
        ymax += R_shift
    else:
        xmin, ymin, xmax, ymax = 0.0, 0.0, 300.0, 100.0

    # Polylines
    polylines = []
    for pm in re.finditer(
        r"pline\s*=\s*new\s+TPolyLine\((\d+),.*?\);\s*(.*?)\bDraw\(", src, flags=re.S
    ):
        block = pm.group(2)
        color = _get_color_hex(block)
        lwm = re.search(r"SetLineWidth\((\d+)\)", block)
        lw = int(lwm.group(1)) if lwm else None
        xs, ys = [], []
        for ptm in re.finditer(
            r"SetPoint\(\s*\d+\s*,\s*([-\d\.Ee+]+)\s*,\s*([-\d\.Ee+]+)\s*\)", block
        ):
            xs.append(float(ptm.group(1)) * units + z_shift)
            ys.append(float(ptm.group(2)) * units + R_shift)
        if len(xs) >= 2:
            polylines.append(dict(x=xs, y=ys, color=color, lw=lw))

    # Lines
    lines = []
    for lm in re.finditer(
        r"new\s+TLine\(\s*([-\d\.Ee+]+)\s*,\s*([-\d\.Ee+]+)\s*,\s*([-\d\.Ee+]+)\s*,\s*([-\d\.Ee+]+)\s*\)\s*;\s*(.*?)\bDraw\(",
        src,
        flags=re.S,
    ):
        x1, y1, x2, y2 = [float(v) * units for v in lm.group(1, 2, 3, 4)]
        x1 += z_shift
        x2 += z_shift
        y1 += R_shift
        y2 += R_shift
        block = lm.group(5)
        color = _get_color_hex(block)
        lwm = re.search(r"SetLineWidth\((\d+)\)", block)
        lw = int(lwm.group(1)) if lwm else None
        lines.append(dict(x1=x1, y1=y1, x2=x2, y2=y2, color=color, lw=lw))

    # TLatex: either via constructor + Draw() or DrawLatex(x,y,"text")
    texts = []
    # Case 1: new TLatex(x,y,"text");
    for tm in re.finditer(
        r'new\s+TLatex\(\s*([-\d\.Ee+]+)\s*,\s*([-\d\.Ee+]+)\s*,\s*"([^"]*)"\s*\)\s*;\s*(.*?)\bDraw',
        src,
        flags=re.S,
    ):
        x, y, txt, block = (
            float(tm.group(1)) * units + z_shift,
            float(tm.group(2)) * units + R_shift,
            tm.group(3),
            tm.group(4),
        )
        color = _get_color_hex(block)
        # Size mapping: ROOT SetTextSize is fraction of pad height; approximate to points
        sm = re.search(r"SetTextSize\(([\d\.Ee+-]+)\)", block)
        size = float(sm.group(1)) if sm else 0.02
        # Alignment: ROOT SetTextAlign(n): 10*H + V (H: 1=left,2=center,3=right; V:1=bottom,2=center,3=top)
        am = re.search(r"SetTextAlign\((\d+)\)", block)
        align = int(am.group(1)) if am else 12  # default ~ left-center
        texts.append(dict(x=x, y=y, txt=txt, color=color, size=size, align=align))

    # Case 2: DrawLatex(x,y,"text")
    for tm in re.finditer(
        r'DrawLatex\(\s*([-\d\.Ee+]+)\s*,\s*([-\d\.Ee+]+)\s*,\s*"([^"]*)"\s*\)', src
    ):
        x, y, txt = (
            float(tm.group(1)) * units + z_shift,
            float(tm.group(2)) * units + R_shift,
            tm.group(3),
        )
        texts.append(dict(x=x, y=y, txt=txt, color=None, size=0.02, align=12))

    # TText
    for tm in re.finditer(
        r'new\s+TText\(\s*([-\d\.Ee+]+)\s*,\s*([-\d\.Ee+]+)\s*,\s*"([^"]*)"\s*\)\s*;\s*(.*?)\bDraw',
        src,
        flags=re.S,
    ):
        x, y, txt, block = (
            float(tm.group(1)) * units + z_shift,
            float(tm.group(2)) * units + R_shift,
            tm.group(3),
            tm.group(4),
        )
        color = _get_color_hex(block)
        sm = re.search(r"SetTextSize\(([\d\.Ee+-]+)\)", block)
        size = float(sm.group(1)) if sm else 0.02
        am = re.search(r"SetTextAlign\((\d+)\)", block)
        align = int(am.group(1)) if am else 12
        texts.append(dict(x=x, y=y, txt=txt, color=color, size=size, align=align))

    return dict(
        range=(xmin, ymin, xmax, ymax), polylines=polylines, lines=lines, texts=texts
    )


def _root_align_to_ha_va(align):
    # ROOT align code: 10*H + V ; H:1 left,2 center,3 right ; V:1 bottom,2 center,3 top
    H = align // 10
    V = align % 10
    ha = {1: "left", 2: "center", 3: "right"}.get(H, "left")
    va = {1: "bottom", 2: "center", 3: "top"}.get(V, "center")
    return ha, va


def draw_detector(
    ax,
    macro_path,
    macro_units_to_cm=1.0,
    z_offset_cm=0.0,
    R_offset_cm=0.0,
    draw_text=True,
):
    """Draw detector primitives and text with cm/cm scaling."""
    parsed = parse_root_macro(
        macro_path, units=macro_units_to_cm, z_shift=z_offset_cm, R_shift=R_offset_cm
    )
    xmin, ymin, xmax, ymax = parsed["range"]
    # lines/polylines
    for L in parsed["polylines"]:
        ax.plot(
            L["x"],
            L["y"],
            color=L["color"] if L["color"] else "black",
            linewidth=L["lw"] if L["lw"] else 1,
        )
    for L in parsed["lines"]:
        ax.plot(
            [L["x1"], L["x2"]],
            [L["y1"], L["y2"]],
            color=L["color"] if L["color"] else "black",
            linewidth=L["lw"] if L["lw"] else 1,
        )
    # text
    if draw_text:
        for T in parsed["texts"]:
            ha, va = _root_align_to_ha_va(T["align"])
            # crude mapping of ROOT text size (fraction of pad height) -> points:
            fontsize = max(6, int(220 * T["size"]))  # 0.02 -> ~4.4 -> clamp to >=6
            kw = dict(ha=ha, va=va)
            if T["color"]:
                kw["color"] = T["color"]
            ax.text(T["x"], T["y"], T["txt"], fontsize=fontsize, **kw)
    # Return range for caller
    ax.set_aspect("equal", adjustable="box")
    return xmin, ymin, xmax, ymax


# -----------------------------
# Physics: helical trajectories
# -----------------------------
c = 299792458.0
GeV_c_to_SI = 5.344285e-19  # 1 GeV/c in kg m/s
e = 1.602176634e-19
m_mu = 1.883531627e-28
Bz = 3.8


def traj_Rz_cm(pT_GeV, eta, q=-e, phi0=0.0, x0=0.0, y0=0.0, z0=0.0, Z_span_cm=300):
    pT = pT_GeV * GeV_c_to_SI
    pz = pT * np.sinh(eta)
    p = pT * np.cosh(eta)
    gamma = np.sqrt(1.0 + (p / (m_mu * c)) ** 2)
    ux, uy = np.cos(phi0), np.sin(phi0)
    vx0, vy0 = (pT * ux) / (gamma * m_mu), (pT * uy) / (gamma * m_mu)
    vz0 = pz / (gamma * m_mu)
    omega_c = q * Bz / (gamma * m_mu)
    Tc = 2 * np.pi / abs(omega_c) if omega_c != 0 else np.inf
    if abs(vz0) > 0:
        t_end = (Z_span_cm / 100.0) / abs(vz0) * 1.1
        if np.isfinite(Tc):
            t_end = max(t_end, 2 * Tc)
    else:
        t_end = 4 * Tc if np.isfinite(Tc) else 1e-6
    t = np.linspace(0, t_end, 2500)
    if omega_c != 0:
        s, ccos = np.sin(omega_c * t), np.cos(omega_c * t)
        x = x0 + (vx0 * s + vy0 * (ccos - 1.0)) / omega_c
        y = y0 + (-vx0 * (ccos - 1.0) + vy0 * s) / omega_c
    else:
        x = x0 + vx0 * t
        y = y0 + vy0 * t
    z = z0 + vz0 * t
    R_cm = 100.0 * np.sqrt(x**2 + y**2)
    z_cm = 100.0 * z
    return z_cm, R_cm


# -----------------------------
# Overlay function
# -----------------------------
def overlay_tracks_on_detector(
    macro_path,
    pT_list,
    eta_list,
    q=-e,
    phi0=0.0,
    x0=0.0,
    y0=0.0,
    z0=0.0,  # meters
    R_window_cm=100,
    Z_window_cm=300,
    follow_z0=True,
    macro_units_to_cm=1.0,  # scale macro units -> cm
    z_offset_cm=0.0,
    R_offset_cm=0.0,  # shifts to align origins
    strict_range=False,  # if True, keep macro's full Range limits (debug alignment)
    figsize=(11, 5),
    out_pdf=None,
    out_png=None,
    png_dpi=300,
    draw_text=True,
    show_grid=True,
):
    fig, ax = plt.subplots(figsize=figsize)
    xmin, ymin, xmax, ymax = draw_detector(
        ax, macro_path, macro_units_to_cm, z_offset_cm, R_offset_cm, draw_text=draw_text
    )

    # Window: either keep macro full range, or set to requested window dynamically
    if strict_range:
        zmin, zmax = xmin, xmax
        rmin, rmax = ymin, ymax
    else:
        z0_cm = 100.0 * z0
        zmin = min(0.0, z0_cm) if follow_z0 else 0.0
        zmax = zmin + Z_window_cm
        rmin, rmax = 0.0, R_window_cm
        ax.set_xlim(zmin, zmax)
        ax.set_ylim(rmin, rmax)

    ax.set_aspect("equal", adjustable="box")

    # Style maps
    linestyles = [
        "-",
        "--",
        "-.",
        ":",
        (0, (5, 1, 1, 1)),
        (0, (3, 1, 1, 1, 1, 1)),
        (0, (5, 2, 5, 2)),
        (0, (1, 1)),
        (0, (3, 5, 1, 5)),
    ]
    colors = (
        plt.rcParams["axes.prop_cycle"]
        .by_key()
        .get("color", ["C0", "C1", "C2", "C3", "C4"])
    )

    # Tracks
    for i_pt, pT in enumerate(pT_list):
        color = colors[i_pt % len(colors)]
        for j_eta, eta in enumerate(eta_list):
            ls = linestyles[j_eta % len(linestyles)]
            z_cm, R_cm = traj_Rz_cm(
                pT, eta, q=q, phi0=phi0, x0=x0, y0=y0, z0=z0, Z_span_cm=Z_window_cm
            )
            outside = (z_cm < zmin) | (z_cm > zmax) | (R_cm < rmin) | (R_cm > rmax)
            z_plot = z_cm.copy()
            R_plot = R_cm.copy()
            z_plot[outside] = np.nan
            R_plot[outside] = np.nan
            ax.plot(z_plot, R_plot, color=color, linestyle=ls, lw=1)

    ax.set_xlabel("z [cm]")
    ax.set_ylabel("R [cm]")

    # 10 cm major ticks
    ax.xaxis.set_major_locator(ticker.MultipleLocator(10))
    ax.yaxis.set_major_locator(ticker.MultipleLocator(10))
    # Optional grid aligned to major ticks
    if show_grid:
        ax.grid(True, which="major", linewidth=0.5, alpha=0.5)

    # Legends beneath the plot
    pt_handles = [
        Line2D([0], [0], color=colors[i % len(colors)], lw=3)
        for i, _ in enumerate(pT_list)
    ]
    pt_labels = [f"pT = {pT} GeV/c" for pT in pT_list]
    eta_handles = [
        Line2D([0], [0], color="black", linestyle=linestyles[j % len(linestyles)], lw=2)
        for j, _ in enumerate(eta_list)
    ]
    eta_labels = [f"eta = {eta}" for eta in eta_list]
    leg1 = ax.legend(
        pt_handles,
        pt_labels,
        title="Color = pT",
        loc="upper center",
        bbox_to_anchor=(0.5, -0.16),
        ncol=max(1, len(pT_list)),
    )
    leg2 = ax.legend(
        eta_handles,
        eta_labels,
        title="Line = eta",
        loc="upper center",
        bbox_to_anchor=(0.5, -0.32),
        ncol=5,
    )
    ax.add_artist(leg1)

    plt.tight_layout()

    if out_pdf:
        with PdfPages(out_pdf) as pdf:
            pdf.savefig(fig, bbox_inches="tight")
    if out_png:
        fig.savefig(out_png, dpi=png_dpi, bbox_inches="tight")
    plt.close(fig)


# -----------------------------
# CLI
# -----------------------------
import argparse
from typing import Optional, List, Tuple


def parse_args(argv: Optional[List[str]] = None) -> argparse.Namespace:
    p = argparse.ArgumentParser(
        description="Overlay R–z helical tracks onto a ROOT macro of the detector."
    )
    p.add_argument(
        "--macro",
        required=False,
        default="fullLayout000.C",
        help="Path to ROOT .C macro (R–z layout)",
    )
    p.add_argument(
        "--pt",
        nargs="+",
        type=float,
        required=False,
        default=[0.8, 1, 2, 10],
        help="List of pT values [GeV/c]",
    )
    p.add_argument(
        "--eta",
        nargs="+",
        type=float,
        required=False,
        default=[0.6, 0.8, 1, 1.2, 1.4, 1.5, 2.5, 3, 4],
        help="List of eta values",
    )
    p.add_argument(
        "--q", type=float, default=-e, help="Particle charge [C] (default: muon -e)"
    )
    p.add_argument(
        "--phi0",
        type=float,
        default=0.0,
        help="Initial azimuth in radians for transverse velocity",
    )
    p.add_argument("--x0", type=float, default=0.0, help="Initial x [m]")
    p.add_argument("--y0", type=float, default=0.0, help="Initial y [m]")
    p.add_argument("--z0", type=float, default=-0.100, help="Initial z [m]")
    p.add_argument("--R-window-cm", type=float, default=125.0, help="Max R shown [cm]")
    p.add_argument("--Z-window-cm", type=float, default=300.0, help="Z span shown [cm]")
    p.add_argument(
        "--follow-z0",
        action="store_true",
        help="Set zmin to min(0, z0) to follow starting z0",
    )
    p.add_argument(
        "--macro-units-to-cm",
        type=float,
        default=0.1,
        help="Scale: cm per macro unit (e.g., 0.1 if macro uses mm)",
    )
    p.add_argument(
        "--z-offset-cm", type=float, default=0.0, help="Shift macro z by this many cm"
    )
    p.add_argument(
        "--R-offset-cm", type=float, default=0.0, help="Shift macro R by this many cm"
    )
    p.add_argument(
        "--strict-range",
        action="store_true",
        help="Use macro canvas Range instead of window params",
    )
    p.add_argument(
        "--figsize",
        nargs=2,
        type=float,
        default=[3000 / 72, 1000 / 72],
        help="Figure size in inches (W H)",
    )
    p.add_argument("--pdf", help="Output PDF path")
    p.add_argument("--png", help="Output PNG path")
    p.add_argument("--png-dpi", type=int, default=72, help="PNG DPI")
    p.add_argument("--no-text", action="store_true", help="Do not draw text from macro")
    p.add_argument("--no-grid", action="store_true", help="Do not draw major grid")
    return p.parse_args(argv)


def main(argv: Optional[List[str]] = None):
    args = parse_args(argv)
    overlay_tracks_on_detector(
        macro_path=args.macro,
        pT_list=args.pt,
        eta_list=args.eta,
        q=args.q,
        phi0=args.phi0,
        x0=args.x0,
        y0=args.y0,
        z0=args.z0,
        R_window_cm=args.R_window_cm,
        Z_window_cm=args.Z_window_cm,
        follow_z0=args.follow_z0,
        macro_units_to_cm=args.macro_units_to_cm,
        z_offset_cm=args.z_offset_cm,
        R_offset_cm=args.R_offset_cm,
        strict_range=args.strict_range,
        figsize=tuple(args.figsize),
        out_pdf=args.pdf,
        out_png=args.png,
        png_dpi=args.png_dpi,
        draw_text=not args.no_text,
        show_grid=not args.no_grid,
    )


if __name__ == "__main__":
    main()
